# -*- coding: utf-8 -*-
"""telco-customers-churn-analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/167j-vb5SeCFGsQn-xx6i-cRQPz7Qopnw

# Telco Customers Churn Analysis
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

df = pd.read_csv('/content/WA_Fn-UseC_-Telco-Customer-Churn.csv')
df.head()

df.columns

"""Replacing blanks with 0 as tenture is 0 and no total charges are recorded"""

df['TotalCharges'] = df['TotalCharges'].replace(' ','0')
df['TotalCharges'] = df['TotalCharges'].astype(float)
df['TotalCharges'].dtypes

df.info() # Check data types & missing values

df.isnull().sum().sum () # Check null values

df.describe()  # Get summary statistics

df['customerID'].duplicated().sum()

"""#Converting 0 & 1 values of  SeniorCitizen to Yes/Not to make it easier to understand"""

def conv(value):
    if value == 1:
        return "Yes"
    else:
        return "NO"
df['SeniorCitizen'] = df['SeniorCitizen'].apply(conv)

df.head()

"""# Customer Churn Distribution"""

plt.figure(figsize = (4,5))
ax = sns.countplot(x = 'Churn', data = df,width = 0.5)
ax.bar_label(ax.containers[0])
plt.title(" Count of Customers by Churn", fontsize = 15)
plt.xlabel("Churn" , fontsize = 15)
plt.ylabel("Count", fontsize = 15)
plt.show()

gb = df.groupby('Churn').agg({'Churn':'count'})
plt.figure(figsize = (4,4))
plt.pie(gb['Churn'], labels = gb.index, autopct = '%1.2f%%',colors = ('steelblue','darkgoldenrod'))
plt.title("Percentage of Churned Customers" , fontsize= 15)
plt.show()

"""### üìå Key Insight: Customer Churn Distribution  
- **Total Customers:** 7,043  
- **Churned Customers:** 1,869 (**26.54%**)  
- **Non-Churned Customers:** 5,174 (**73.46%**)  
- **Observation:** Nearly **one-fourth** of customers have churned, suggesting a need for deeper analysis into the factors influencing customer retention.  

#Let's explore the reason behind it.

# Churn by Gender
"""

plt.figure(figsize = (4,4))
sns.countplot(x = 'gender',data = df, hue = 'Churn')
plt.title(" Churn by Gender", fontsize= 15)
plt.xlabel("Gender", fontsize= 15)
plt.ylabel("Count" , fontsize= 15)
plt.show()

"""# Key Insight: Churn Rate by Gender
üìä The distribution of churned vs. non-churned customers is nearly identical for both genders.

- Female Customers: Slightly over 2,500 stayed, while around 900‚Äì1,000 churned.
- Male Customers: A similar trend is observed, with churn and retention rates almost equal to females.

**üîç Observation:**

- Gender does not seem to be a significant factor in customer churn, as both male and female customers have nearly the same churn rate.
- This suggests that other factors, such as service quality, contract type, or pricing, might have a bigger impact on churn than gender alone.

# Churn by Senior Citizen
"""

plt.figure(figsize = (4,5))
ax = sns.countplot(x = 'SeniorCitizen', data = df,  palette= 'colorblind')
ax.bar_label(ax.containers[0])
plt.title("Churn by SeniorCitizen", fontsize= 15)
plt.xlabel("SeniorCitizen", fontsize= 15)
plt.ylabel("Count" , fontsize= 15)
plt.show()

# Calculate the percentage of each Churn category within each SeniorCitizen group
grouped = df.groupby(['SeniorCitizen', 'Churn']).size().unstack()     #Grouping Data by 'SeniorCitizen' and 'Churn'
grouped_percentage = grouped.div(grouped.sum(axis=1), axis=0) * 100   #Converting Counts into Percentages

# Plotting
ax = grouped_percentage.plot(kind='bar', stacked=True, figsize=(4, 5), color=['purple', 'orange'])

# Adding labels as percentages
for p in ax.patches:
    width, height = p.get_width(), p.get_height()
    x, y = p.get_xy()
    ax.annotate(f'{height:.1f}%', (x + width/2, y + height/2), ha='center')

plt.title("Churn by SeniorCitizen (Percentage)", fontsize = 15)
plt.xlabel('SeniorCitizen',fontsize= 15)
plt.ylabel('Percentage', fontsize= 15)
plt.xticks(rotation=0)
plt.legend(title='Churn')
plt.show()

"""# Key Insight: Churn Rate Among Senior Citizens
üìä The churn rate varies significantly based on seniority:

 - **Non-Senior Customers:**
 - 76.4% stayed, while 23.6% churned.
 - **Senior Citizens:**
 - Only 58.3% remained, while a much higher 41.7% churned.
   
**üîç Observation:**

- Senior citizens have a higher churn rate than non-senior customers, nearly 1.8 times higher (41.7% vs. 23.6%).
- This suggests that elderly customers might face difficulties with service usage, pricing, or contract terms, making them more likely to leave.
- Companies should consider senior-friendly retention strategies, such as better support, discounts, or simplified plans.

# Churn Rate Vs  Customer Tenure
"""

sns.histplot(x = "tenure", data = df, bins = 50, hue = 'Churn')
plt.show()

"""# Key Insight: Churn Rate vs. Customer Tenure
üìä The relationship between customer tenure (length of time with the company) and churn shows some clear patterns:

 **High Churn Among New Customers:**
 - A large number of customers churn within the first few months, indicating early dissatisfaction or lack of engagement.
 **Lower Churn for Long-Term Customers:**
- Customers with longer tenures (above 20 months) tend to stay, with fewer churn cases.
 **Spike at 70+ Months:**
 - There is a sharp increase in customer count at the 70-month mark, likely due to long-term contract completions.
 -
**üîç Observations & Business Impact:**

- Retention efforts should focus on new customers, improving onboarding, service experience, and engagement in the first few months.
- Customers who stay beyond 20 months are less likely to churn, making them valuable for long-term retention strategies.
- The spike at 70 months suggests that a large portion of customers complete a contract term. Companies should offer incentives or renewal benefits to   retain them.

#  Churn Rate by Contract Type
"""

plt.figure(figsize = (4,5))
ax = sns.countplot(x = 'Contract', data = df,hue = "Churn")
ax.bar_label(ax.containers[0])
ax.bar_label(ax.containers[1])
plt.title("Count of Customers by Contract",fontsize= 15)
plt.xlabel("Contract",fontsize= 15)
plt.ylabel("Count", fontsize= 15)
plt.show()

"""# Key Insight: Churn Rate by Contract Type
üìä The type of contract significantly impacts customer churn rates:

**Month-to-Month Contracts:**

 - Highest churn rate, with 1,655 churned customers.
- More than 40% of these customers leave, indicating flexibility might lead to frequent churn.
    
**One-Year Contracts:**

- Much lower churn, with only 166 customers leaving.
- Customers in longer-term commitments tend to stay.

**Two-Year Contracts:**

- Lowest churn rate, with just 48 customers leaving.
- Most stable customer base, suggesting long-term contracts encourage retention.
  
**üîç Observations & Business Impact:**

- Short-term contracts lead to high churn, indicating customers prefer flexibility but are also quick to leave.
- Long-term contracts improve retention, meaning incentives like discounts or better service for long-term commitments could help reduce churn.
- Companies should target month-to-month customers with retention strategies, such as loyalty programs, better customer service, or contract upgrade offers.
"""

# List of columns to plot
columns = ['PhoneService', 'MultipleLines', 'InternetService',
           'OnlineSecurity', 'OnlineBackup', 'DeviceProtection',
           'TechSupport', 'StreamingTV', 'StreamingMovies']

# Create a figure with subplots
fig, axes = plt.subplots(3, 3, figsize=(15, 15))  # 3 rows, 3 columns
fig.suptitle('Count Plots for Categorical Features', fontsize=16)

# Flatten the axes array for easy iteration
axes = axes.flatten()

# Loop through each column and create a count plot
for i, column in enumerate(columns):
    sns.countplot(x=column, data=df, ax=axes[i], palette='viridis',hue = df['Churn'])
    axes[i].set_title(f'Count Plot of {column}')
    axes[i].set_xlabel(column)
    axes[i].set_ylabel('Count')

# Adjust layout to prevent overlap
plt.tight_layout(rect=[0, 0, 1, 0.96])  # Adjust the rect to make space for the suptitle
plt.show()

"""# Key Insights: Churn Analysis for Categorical Features
üìä The charts reveal the relationship between different services and customer churn.

**Phone Service & Multiple Lines**

- Most customers have Phone Service, but churn is higher among those with it.
- Having Multiple Lines does not significantly impact churn.
  
 **Internet Service**
  
- Fiber Optic users churn more compared to DSL users.
- Customers without Internet Service churn the least, suggesting bundled services may impact retention.
  
 **Online Security, Backup & Device Protection**
  
- Customers with Online Security, Backup, and Device Protection churn less than those without.
- Lack of these services correlates with higher churn, suggesting security features might be a retention factor.
  
**Tech Support**
  
- Customers without Tech Support churn more, indicating that better support services may improve retention.

**Streaming Services (TV & Movies)**
  
- Having Streaming Services does not significantly impact churn, meaning entertainment services might not be a key churn driver.
  
**üîçKey Takeaways & Business Actions:**
  
 - Promote Security & Support Services ‚Äì Customers with Online Security, Device Protection, and Tech Support churn less, so these should be bundled or
 - incentivized.
 - Improve Fiber Optic Retention ‚Äì High churn among Fiber Optic users suggests issues with pricing, service quality, or competition. Addressing these
 - can improve retention.
 - Internet Service Matters More Than Entertainment ‚Äì Streaming services have no major impact on churn, so marketing efforts should focus on core
 - services like security and tech support.

# Churned  of Customers by Payment Method
"""

plt.figure(figsize = (6,5))
ax = sns.countplot(x = 'PaymentMethod', data = df,hue = "Churn",palette='viridis')
ax.bar_label(ax.containers[0])
ax.bar_label(ax.containers[1])
plt.title("Churned  of Customers by Payment Method",fontsize=15)
plt.xticks(rotation = 45)
plt.xlabel("PaymentMethod",fontsize=15)
plt.ylabel("Count",fontsize=15)
plt.show()

"""# Key Insights: Churn by Payment Method
üìä This chart shows the churn distribution across different payment methods.

**Highest Churn: Electronic Check**
- Electronic Check has the highest churn rate (1071 churned customers).
- This suggests that customers using electronic checks may face payment difficulties, or they prefer flexibility and are more likely to switch.
**Lower Churn in Automatic Payments**
- Automatic payments (Bank Transfer & Credit Card) have the lowest churn rates (only 258 and 232 churned customers, respectively).
- This indicates that customers who set up automatic payments tend to stay longer, possibly due to convenience and commitment.
**Mailed Checks Have Moderate Churn**
- Mailed Checks show moderate churn (308 customers).
- This suggests that customers using traditional payment methods are relatively stable but still more prone to churn than automatic payment users.
  
**üîç Key Takeaways & Business Actions:**
- Encourage Automatic Payments ‚Äì Offer discounts, incentives, or loyalty points for customers who switch to auto-pay methods like bank transfers or credit cards.
- Investigate Electronic Check Issues ‚Äì Understand why these customers churn more. Are there hidden fees, payment failures, or dissatisfaction with service? Addressing these issues can reduce churn.
- Monitor Mailed Check Users ‚Äì While churn is moderate, improving ease of payment (e.g., reminders, digital payment options) can retain more customers.

# Overall Conclusion of Telco Churn Customers Analysis
The Telco Churn Analysis provides key insights into customer behavior, highlighting significant factors influencing churn.

**Tenure Impact:**

Customers with shorter tenures (0‚Äì10 months) have the highest churn rates, indicating that early-stage retention is a major challenge.
Long-term customers (above 60 months) are less likely to churn.
    
**Contract Type:**

Month-to-month contract users have the highest churn rate, as they have more flexibility to leave.
One-year and two-year contract customers show significantly lower churn, suggesting that long-term contracts increase retention.
    
**Internet Service & Add-ons:**

Customers using Fiber optic internet have higher churn rates compared to DSL users.
Lack of online security, backup, and tech support services is associated with higher churn. Offering bundled services could improve retention.

**Payment Methods:**

Customers using Electronic Check have the highest churn rate, indicating possible dissatisfaction with this method.
Automatic payment methods like bank transfers and credit cards are linked with lower churn, suggesting a preference for convenience.

# Model Selection
"""

from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from xgboost import XGBClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

# Define features (X) and target variable (y)
X = df.drop(['Churn', 'customerID'], axis=1) # Drop 'customerID'
y = df['Churn']

# Convert categorical features to numerical using Label Encoding
for column in X.select_dtypes(include=['object']).columns:
    le = LabelEncoder()
    X[column] = le.fit_transform(X[column])

# Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Scale numerical features using StandardScaler (optional but recommended)
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

"""# Random Forest

"""

# Model Training (Random Forest Classifier)
model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Model Evaluation
y_pred = model.predict(X_test)

print("Classification Report:")
print(classification_report(y_test, y_pred))

print("\nConfusion Matrix:")
print(confusion_matrix(y_test, y_pred))

print("\nAccuracy:", accuracy_score(y_test, y_pred))

"""# Logistic Regression"""

# Model Training (Logistic Regression)
model = LogisticRegression(max_iter=1000, random_state=42)
model.fit(X_train, y_train)

# Model Evaluation
y_pred = model.predict(X_test)

print("Classification Report:")
print(classification_report(y_test, y_pred))

print("\nConfusion Matrix:")
print(confusion_matrix(y_test, y_pred))

print("\nAccuracy:", accuracy_score(y_test, y_pred))

"""# Decision Tree"""

# Model Training (Decision Tree)
model = DecisionTreeClassifier(random_state=42)
model.fit(X_train, y_train)

# Model Evaluation
y_pred = model.predict(X_test)

print("Classification Report:")
print(classification_report(y_test, y_pred))

print("\nConfusion Matrix:")
print(confusion_matrix(y_test, y_pred))

print("\nAccuracy:", accuracy_score(y_test, y_pred))

"""## SVM"""

# Model Training (SVM)
model = SVC(random_state=42)
model.fit(X_train, y_train)

# Model Evaluation
y_pred = model.predict(X_test)

print("Classification Report:")
print(classification_report(y_test, y_pred))

print("\nConfusion Matrix:")
print(confusion_matrix(y_test, y_pred))

print("\nAccuracy:", accuracy_score(y_test, y_pred))

"""# Best Model Selection

While Logistic Regression and SVM perform well in terms of recall and precision, Random Forest provides robust generalization capabilities. However, Logistic Regression achieves the highest overall accuracy, making it the best model for interpretability and practical implementation
"""

